# Pro Git笔记

本篇笔记是对 Pro Git 2nd 的阅读心得，记录每一个章节个人认为重要且需要扩展理解的方面。

[TOC]



## 版本控制

我们在安装一系列软件的时候，会发现软件有多个版本，我们会选择需要的版本进行安装。在linux中，任何事物都可以作为文件存在，现在我们套用这套逻辑，那么我们的文件就如同软件一样，有着不同的版本，每一次对文件的修改操作就是一次版本的更迭。

现在让我们回答一下什么是版本控制——**版本控制是一种记录一个或若干文件内容变化**，以便将来查阅特定版本修订情况的系统。在维基中，版本控制被描述成维护工程蓝图的做法，可追踪自诞生至定案的过程。

有了版本控制，我们对文件的修改更为大胆了。因为我们不用害怕我们的操作是错的，如果是，那么就回退到正确的时候。这是方便的。

### 集中式版本控制

如果只是一个人的开发，版本控制似乎作用不太大，或者说没有发挥其全部的作用。

当多人协作开发时，我们需要版本控制，我们需要团队人员有自己的开发行为，并最终汇总到项目中。

集中式版本控制*CVCS*，将项目部署到服务器端，团队开发者可以获取项目**最新快照**，做出自己的更改，然后提交。 

![](image/CVCS.png)

**\*\*【注意】如果服务器数据全部丢失，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。\*\***



### 分布式版本控制系统

分布式*DVCS*解决了这个问题——**客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。**

当任何一处协同工作的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。

![](image/DVCS.png)

### Git简述

Git的内容是重点内容，这里是Git的基本理论部分。

#### 直接记录快照，而非差异比较

传统的*DVCS*做版本控制时，以文件变更列表的方式存储信息。

什么意思呢？就是说**记录当前版本文件较前一个版本的修改内容**，这是一种**线性**的版本控制模型。理解很直观，缺点就是回退起来很麻烦。如果要从v3.1.1 回退到 v2.0.0可能中间需要经过数个版本的回退，比如

v3.1.1 --back--> v3.1.0 --back--> v3.0.0 --back--> ... (process verison) --back-->v2.0.0

![](image/DVCS-update.png)

而Git 更像是把数据看作是对小型文件系统的一组**快照**。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 **快照流**。

![](image/Git-update.png)

#### Git 保证完整性

Git 中所有数据在存储前都计算**校验和**，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。

Git 用以计算校验和的机制叫做 **SHA-1 散列**（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来（实际还包括一些其他元数据，比如日期作者）。 SHA-1 哈希看起来是这样：

```
24b9da6552252987aa493b52f8696cd6d3b00373
```

**【注意】Git中的每个对象（blob、tree、commit 等）都会有一个校验和**



我们可以看一个 git项目的例子 在.git\objects\ 下：

```
- 3b
- | - 18e512dba79e4c8300dd08aeb37f8e728b8dad
- 4c
- | - dfbf5620c65792070ba5b804f904c4b9226b3b
- ...
```

我们实际上有两个校验和(hash)，目录本身2个16进制的字符，文件名有38个，2+38=40。

这两个校验和都是 blog 文件内容的校验和，可以查看文件快照

> ```
> > git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
> 
> > hello world // 这个快照下，该blob内容是hello word
> ```



现在我们来看一个更为复杂的

> ```
> > git cat-file -p d17e0c513a4805f0921f8fb7c60849f4a1573daf // commit object 校验和，包含以下信息
> tree cdc9bcb17bec4fedf117a0cec4c0dc6566030f48              // 提交的 树对象(tree object) 的校验和
> parent c2747b29ad4df16cdab8a56fd498aa2e2091f92f            // 父提交（线性）的校验和
> author Jiam Zhang <2386484961@qq.com> 1701328395 +0800     // 作者信息：名称 邮箱 时间戳 时区
> committer Jiam Zhang <2386484961@qq.com> 1701328395 +0800  // 提交者信息：名称 邮箱 时间戳 时区
> 
> rename file                                                // 提交时消息
> 
> > git cat-file -p cdc9bcb17bec4fedf117a0cec4c0dc6566030f48              // tree object 校验和，包含以下信息
> 100644 blob 266c01d692ef860ab5e0f8724c415ece32248a27    README.md       // 普通文件 blog object 校验和
> 100644 blob 63a7efa5066dcbf3a02a384443f7d5ecb1b88dbb    main.txt        // 普通文件 blog object 校验和
> 
> > git cat-file -p 266c01d692ef860ab5e0f8724c415ece32248a27      // blog object 校验和，下面是文件内容
> # hello-world
> hello-world
> # new branch
> - one
> - two
> 
> > git cat-file -p 63a7efa5066dcbf3a02a384443f7d5ecb1b88dbb      // blog object 校验和，下面是文件内容
> hello world
> 你好
> ```

我们可以通过校验和查看任何Git目录下的文件信息，同时校验和也保证了所有文件的完整性。我们不可能说更改一个已经提交的文件快照——这样校验和会错误。



### Git三种状态

在Git项目下，每一个文件都会是三种状态之一：

- 已修改（modified）    修改了文件，但还没保存到数据库中
- 已暂存（staged）        对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中
- 已提交（committed）数据已经安全的保存在本地数据库中



由此引入 Git 项目的三个工作区域的概念：

- 工作目录 working directory **对项目的某个版本独立提取出来的内容**。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。

- 暂存区域 staging area **一个文件，保存了下次将提交的文件列表信息**。

- Git 仓库   git directory (repository)  **保存项目的元数据和对象数据库的地方**。最重要，从其它计算机克隆仓库时，拷贝的就是这里的数据。

![](image/git-status-areas.png)

基本的 Git 工作流程如下：

1. 在工作目录中修改文件。
2. 暂存文件，将文件的快照放入暂存区域。
3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。

如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。























